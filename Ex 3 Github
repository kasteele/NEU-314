using PyPlot
image = imread("el-capitan.png")
size(image)
imshow(convert(typeof(image), image))
title("El-Capitan")
axis("off")
figure(figsize=[100,100])

typeof(image)

"""
image_read_and_extract_colors -- This function reads in an
image and returns the R, G, and B channels as separate
variables.

The function takes in a filename and reads in image data and
shows the image. It then separates the data to three separate
arrays that hold the data for the R, G, and B channels. We
ignore the alpha channel (index 4) in this exercise set. It
then returns the separate channel data in the form of arrays.

Args:
   arg1, filename (str): arg1 is the filename of
   the image you want to extract the R,G,B channels
   from

Returns:
   out (three arrays of type Array{Float32,2}):
   Each array is the R, G, and B channel data respectively.
"""

function image_read_and_extract_colors(filename)
    image = imread(filename)
    imshow(convert(typeof(image), image))


    RChannel = image[:,:,1]
    GChannel = image[:,:,2]
    BChannel = image[:,:,3]

    println("Reset with git reset --mixed")

    return RChannel, GChannel, BChannel

end

image_read_and_extract_colors("el-capitan.png")


#= part e
Set image2[:,:,1] to be the G channel,
image2[:,:,2] to be the B channel,
and image2[:,:,3] to be the
R channel from the original image. =#

image = imread("el-capitan.png")
image2 = copy(image)

R,G,B = image_read_and_extract_colors("el-capitan.png")

image2[:,:,1] = G
image2[:, :, 2] = B
image2[:, :, 3] = R


clf()

# show the images side by side
subplot(1,2,1, title = "original image")
imshow(convert(typeof(image), image))

axis("off")

subplot(1,2,2, title = "color altered image")
imshow(convert(typeof(image2), image2))

axis("off")
figure(figsize=[100,100])

#= part 1)B
A “circular” rotation of elements in a matrix
moves the contents of the matrix such that
elements that “fall off” one edge “circle back”
to the opposite edge.
Write a function that, for given an image,
circularly moves only one channel, the red
channel (remember, this is the first one) up
some number of pixels, p, such that the
top p rows now become the bottom p rows. Your
function should take two arguments -- 1)
your image and 2) the number of pixels you
want to shift it by -- and return the shifted image.
Display both the original image channel
and the result of circularly moving the red channel
up by 180 pixels.  =#

"""
Cirular Rotation -- This function circularly moves the red
channel in a give image by the number of pixels specified.

The function reads in the image and defines the definition
of the image. It then account for if the shift number
(shift_num) given is larger than the dimensions of the
image. It then makes a copy of the image. The first
for loop shifts the appropriate number of rows by
making the first shift_num rows the bottome shift_num
rows of the image. The second loop shifts the "non-shifted"
rows up, so that the row below the last shifted row appears
at the top of the image. It returns the shifted copy of
the image.


Args:
   filename, arg1 (str): arg1 is the filename of the image
   you want to shift the pixels of
   arg2 (str): Description of arg2

Returns:
   out (image, Array{Float32,3}): The function returns
   a shifted copy of the original image with the red
   channel shifted as defined by the shift number.
"""


function circular_rotation(filename, shift_num)

    image = imread(filename)
    dimensions = size(image)
    dimX = dimensions[1]

    while shift_num > dimX
        shift_num = shift_num - dimX
    end


    copy2 = copy(image)

    for i = 1:shift_num
        copy2[end - shift_num + i, :, 1] = image[i, :, 1]
    end

    for i = 1:(dimX - shift_num)
       copy2[i,:,1]= image[i + shift_num, :,1]

    end

    return copy2
end

clf()


shifted = circular_rotation("el-capitan.png", 180)

imshow(convert(typeof(shifted), shifted))

axis("off")
title("Red Shifted Image")
figure(figsize=[100,100])
